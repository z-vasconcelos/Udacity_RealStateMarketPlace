// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
var ERC721MintableComplete = artifacts.require('SolnSquareVerifier');
var Verifier = artifacts.require('Verifier');
const zproof = require("../../zokrates/home/zokrates/code/square/proof.json");

contract ('TestSquareVerifier', accounts => {
    const account_one = accounts[0];
    const account_two = accounts[1];

    const mintableContractName = "AlmostRealState";
    const mintableContractSymbol = "ARSM";
    const mintableContractBaseTokenURI = "https://s3-us-west-2.amazonaws.com/udacity-blockchain/capstone/";

    //Used a pinned cid from pinata to hold the images
    //const mintableContractBaseTokenURI = "https://gateway.pinata.cloud/ipfs/";
    //const tokenUri = "QmUY3UPGpnjLsiNiwASjcepjJN2z98kjkzvbZW9V5QGJeN/";
    //const completeTokenUri = "https://gateway.pinata.cloud/ipfs/QmUY3UPGpnjLsiNiwASjcepjJN2z98kjkzvbZW9V5QGJeN/";

    describe('Test for SolnSquareVerifier', function () {
        beforeEach(async function () { 
            let VerifierContract = await Verifier.new({from: account_one});
            this.contract = await ERC721MintableComplete.new(
                                                            mintableContractName,
                                                            mintableContractSymbol,
                                                            mintableContractBaseTokenURI,
                                                            VerifierContract.address,
                                                            {from: account_one}
            );
        });

        // Test verification with correct proof
        // - use the contents from proof.json generated from zokrates steps
        it('Can validate a solution', async function() {
            let tokenId = 1;
            try {
                await this.contract.addSolution(
                    zproof.proof.a,
                    //zproof.proof.a_p,
                    zproof.proof.b, 
                    //zproof.proof.b_p,
                    zproof.proof.c,
                    //zproof.proof.c_p,
                    //zproof.proof.h,
                    //zproof.proof.k,
                    zproof.inputs,
                    account_two,
                    tokenId,
                    {from: account_two}
                );                
            } catch (error) {

            }

            let isSolutionSolved = await this.contract.hasSolution.call(
                                                                        zproof.proof.a,
                                                                        zproof.proof.b, 
                                                                        zproof.proof.c,
                                                                        zproof.inputs,
                                                                        {from: account_two}
            );

            assert.equal(isSolutionSolved, true, "The solution was not added. Trying to check the solution it returned: " + isSolutionSolved);

        });

        // Test verification with incorrect proof
        //0x0000000000000000000000000000000000000000000000000000000000000000   
        it('Check if can not validate a solution with fake proof', async function() {
            let tokenId = 1;
            let fake_a = [
                '0x0000000000000000000000000000000000000000000000000000000000000000',
                '0x0000000000000000000000000000000000000000000000000000000000000009'
            ];

            //passing fake_a to test
            try {
                await this.contract.addSolution(
                    fake_a,
                    //zproof.proof.a_p,
                    zproof.proof.b, 
                    //zproof.proof.b_p,
                    zproof.proof.c,
                    //zproof.proof.c_p,
                    //zproof.proof.h,
                    //zproof.proof.k,
                    zproof.inputs,
                    account_two,
                    tokenId,
                    {from: account_two}
                );                
            } catch (error) {

            }

            let isSolutionSolved = await this.contract.hasSolution.call(
                                                                        zproof.proof.a,
                                                                        zproof.proof.b, 
                                                                        zproof.proof.c,
                                                                        zproof.inputs,
                                                                        {from: account_two}
            );

            assert.equal(isSolutionSolved, false, "The solution was added but should have return false. Trying to check the solution it returned: " + isSolutionSolved);

        });    
    });
});
